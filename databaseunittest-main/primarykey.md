프라이머리 키(Primary Key)는 데이터베이스 테이블에서 **각 행(Row, 튜플)을 고유하게 식별하기 위한 키**입니다.

### ✅ 특징 요약:

| 항목 | 설명 |
| --- | --- |
| **고유성(Unique)** | 테이블의 각 행은 프라이머리 키 값을 통해 서로 구별됩니다. 중복될 수 없습니다. |
| **널 값 없음(Not Null)** | 프라이머리 키는 `NULL` 값을 가질 수 없습니다. (즉, 모든 행이 반드시 값을 가져야 합니다.) |
| **하나의 테이블에 하나만 존재** | 하나의 테이블에는 프라이머리 키가 **오직 하나만** 존재할 수 있습니다. (복합 키 포함 가능) |
| **행(Row)의 식별자** | 현실 세계의 엔티티(ex. 사용자, 주문, 상품 등)의 고유 식별자 역할을 합니다. |

### ✅ 예시

```
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100)
);
```

-   여기서 `id`가 프라이머리 키이며, 각 `users` 테이블의 행을 고유하게 식별합니다.

### ✅ 참고: 복합 프라이머리 키

프라이머리 키는 하나 이상의 컬럼으로 구성될 수도 있습니다. 이를 **복합 키(Composite Key)** 라고 합니다.

```
CREATE TABLE order_items (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id)
);
```

-   여기서는 `order_id`와 `product_id`의 조합이 프라이머리 키입니다.
-   즉, 한 주문에 동일한 상품이 두 번 등장하지 않음을 보장합니다.

**UNIQUE KEY**는 **한 테이블 내에서 특정 열(또는 열들의 조합)이 중복되지 않도록 보장하는 제약 조건**입니다.

## ✅ 유니크 키란?

| 항목 | 설명 |
| --- | --- |
| **고유성(Unique)** | 컬럼(또는 컬럼 조합)의 값이 테이블 내에서 중복되지 않아야 합니다. |
| **NULL 허용 여부** | `NULL` 값을 허용합니다. 단, DBMS에 따라 **한 개 이상의 NULL이 허용**됩니다 (예: MySQL). |
| **하나의 테이블에 여러 개 생성 가능** | 하나의 테이블에 **여러 개의 UNIQUE KEY**를 정의할 수 있습니다. |
| **프라이머리 키와 차이점** | 프라이머리 키는 **무조건 하나만 가능하고 NULL 불가**지만, 유니크 키는 **여러 개 가능하고 NULL 허용**입니다. |

## ✅ 예제

```
CREATE TABLE users (
    id INT PRIMARY KEY,
    email VARCHAR(255) UNIQUE,
    username VARCHAR(100),
    CONSTRAINT unique_username UNIQUE(username)
);
```

-   `id` → 프라이머리 키 (고유하고, NULL 불가)
-   `email` → 유니크 키 (중복 안 되지만, NULL 가능)
-   `username` → 유니크 키 (CONSTRAINT 이름 지정해서 설정)

## ✅ 프라이머리 키 vs 유니크 키 비교

| 항목 | PRIMARY KEY | UNIQUE KEY |
| --- | --- | --- |
| 중복 허용 | ❌ (중복 불가) | ❌ (중복 불가) |
| NULL 허용 | ❌ (불가) | ✅ (허용, DBMS에 따라 여러 개도 허용) |
| 개수 | 1개만 허용 | 여러 개 가능 |
| 용도 | 주 식별자 | 보조 식별자 |

## ✅ 언제 UNIQUE 키를 사용하나요?

-   주민등록번호, 이메일 주소, 휴대폰 번호처럼 **고유해야 하지만 프라이머리 키로는 사용하지 않는 값**에 유니크 키를 부여합니다.
-   사용자명(username)처럼 프라이머리 키로 쓰지 않더라도 **중복이 허용되면 안 되는** 경우에 유니크 키를 사용합니다.

**왜 주민등록번호(또는 사회보장번호 등 식별 가능한 개인정보)를 데이터베이스의 프라이머리 키(기본키)로 사용하지 않는지**는 실무에서 매우 중요한 주제입니다.

## ✅ 이유 1: **개인정보 보호(보안 문제)**

주민등록번호는 매우 민감한 **개인 식별 정보**입니다.  
이걸 기본키로 쓰면 아래와 같은 보안 문제가 발생합니다:

-   기본키는 **조인, 검색, 외래 키 등에서 자주 사용되며 자주 노출됩니다.**
-   로그, 백업, 테스트 DB, 쿼리 기록 등에 기본키가 남으면 **주민번호도 같이 노출**될 위험이 큽니다.
-   **개인정보보호법 및 GDPR** 등에서는 이런 식별 정보를 반드시 암호화하거나 최소화하라고 권장합니다.

## ✅ 이유 2: **변경 가능성 존재**

주민번호는 "절대 안 바뀐다"는 전제가 있지만, 실제로는 **변경될 수 있습니다.**

-   실명 정정, 성별 오류, 위조 피해, 성전환 등에 따라 주민번호가 바뀌는 사례가 있습니다.
-   기본키는 **절대로 바뀌지 않는 값**이어야 하는데, 주민번호는 이 원칙을 깰 수 있습니다.

> 기본키는 '불변성(immutability)'이 있어야 합니다. 주민번호는 변경 가능성이 있으므로 적합하지 않습니다.

## ✅ 이유 3: **프라이머리 키의 본래 목적과 맞지 않음**

프라이머리 키는 테이블의 **기술적인 식별자**입니다.  
현실 세계의 식별자(주민번호, 이메일 등)는 **비즈니스 로직 상의 고유값**이지, 시스템에서 사용하기 적절한 기술적 식별자는 아닙니다.

-   주민번호는 **사용자의 의미를 담고 있는 데이터** → 의미 있는 키 (natural key)
-   프라이머리 키는 **의미가 없는 무작위 숫자**가 더 적절 → 대체 키(surrogate key), 보통 AUTO\_INCREMENT 정수 사용

## ✅ 이유 4: **복잡한 관계에서 사용하기 불편**

예를 들어, 다른 테이블에서 주민번호를 외래 키로 사용해야 한다면:

-   주민번호는 문자열이고 길며, 성능에도 좋지 않음
-   외래 키 제약 걸고 조인하면 성능 저하
-   주민번호 변경 시 **참조 무결성 유지가 어려움**

## ✅ 결론

> 주민번호는 고유한 값이지만 **기본키로 적합하지 않습니다.**  
> 대신, AUTO\_INCREMENT된 정수형 ID 같은 **대체 키(Surrogate Key)** 를 기본키로 사용하고,  
> 주민번호는 유니크 키 또는 일반 컬럼 + 마스킹/암호화 처리하는 것이 **보안·유지보수 측면에서 안전합니다.**
