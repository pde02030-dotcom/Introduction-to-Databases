## 🥇 제1 정규형 (First Normal Form, 1NF)

1NF는 정규화의 **가장 기본 단계**이며, 관계형 데이터베이스의 테이블이 갖춰야 할 최소한의 자격입니다.

### 1. 🔑 1NF의 정의 및 조건

**1NF를 만족하는 조건:**

1.  **테이블의 모든 도메인(컬럼 값)은 원자값(Atomic Value)이어야 합니다.**
2.  모든 행을 유일하게 식별할 수 있는 **기본 키(Primary Key)**가 정의되어야 합니다.

### 2. 🚨 1NF 위반 상황: 복합 속성과 반복 그룹

1NF를 위반하는 주된 경우는 두 가지입니다.

#### A. 복합 속성 (Composite Attribute)

하나의 속성(컬럼)이 여러 개의 독립된 의미를 가진 값을 포함하는 경우입니다.

| 직원 ID | 직원 이름 | **주소** |
| :---: | :---: | :---: |
| 101 | 김민준 | 서울특별시, 강남구, 테헤란로 |

* **문제:** '주소' 컬럼이 '시', '구', '도로' 등 여러 의미를 가진 정보를 한 칸에 담고 있어, 특정 부분만 검색하거나 수정하기 어렵습니다.

#### B. 반복 그룹 (Repeating Groups)

하나의 속성(컬럼)에 여러 개의 값(Multi-valued)을 리스트 형태로 저장하거나, 여러 개의 컬럼이 동일한 의미를 반복하는 경우입니다.

**< 1NF 위반 테이블: 고객 취미 목록 >**

| 고객 ID (PK) | 고객 이름 | **취미** |
| :---: | :---: | :---: |
| C001 | 박지수 | **독서, 여행, 요리** |
| C002 | 이서준 | 게임 |

* **문제:** '취미' 컬럼에 여러 값(독서, 여행, 요리)이 들어가 있습니다. 이 상태로는 특정 취미(예: 독서)를 가진 고객을 효율적으로 검색할 수 없으며, 데이터 관리 및 확장성이 떨어집니다.

### 3. ✅ 1NF로 정규화

반복 그룹을 제거하고 각 셀에 하나의 원자값만 존재하도록 **행을 분리**합니다.

**< 1NF 만족 테이블: 고객 취미 목록 >**

| 고객 ID (PK) | 취미 (PK) | 고객 이름 |
| :---: | :---: | :---: |
| C001 | 독서 | 박지수 |
| C001 | 여행 | 박지수 |
| C001 | 요리 | 박지수 |
| C002 | 게임 | 이서준 |

* **결과:** 이제 각 셀에는 하나의 값만 존재합니다.
* **새로운 기본 키:** **(고객 ID, 취미)**와 같은 복합 키가 정의됩니다.
* **효과:** 이제 '독서' 취미를 가진 고객을 쉽게 검색할 수 있습니다.



---
---

## 🥈 제2 정규형 (Second Normal Form, 2NF)

2NF는 1NF를 만족한 테이블에서 **데이터 중복**을 줄이고 **갱신 이상**을 방지하는 첫 번째 단계입니다.

### 1. 🔑 2NF의 정의 및 조건

**2NF를 만족하는 조건:**

1.  **1NF를 만족해야 합니다.**
2.  **기본 키가 아닌 모든 속성**은 **기본 키 전체**에 **완전 함수적 종속(Full Functional Dependency)**이어야 합니다.

### 2. 🚨 2NF 위반 상황: 부분 함수 종속성 (Partial Dependency)

**부분 함수 종속성**이란, 기본 키가 **복합 키(Composite Key)**일 때, 기본 키의 **일부 속성**에만 종속되는 비-키(Non-Key) 속성이 존재하는 경우를 말합니다.

**< 2NF 위반 테이블: 주문 상세 테이블 >**

| 주문번호 (PK) | 상품번호 (PK) | 수량 | **상품명** | **상품가격** |
| :---: | :---: | :---: | :---: | :---: |
| 100 | P001 | 2 | 노트북 | 1,500,000 |
| 100 | P002 | 1 | 마우스 | 30,000 |
| 101 | P001 | 3 | 노트북 | 1,500,000 |

* **기본 키:** 복합 키인 **(주문번호, 상품번호)**
* **함수 종속 관계 분석:**
    * **(주문번호, 상품번호) $\rightarrow$ 수량**: `수량`은 전체 기본 키에 종속됩니다. (**완전 종속**)
    * **상품번호 $\rightarrow$ 상품명, 상품가격**: `상품명`과 `상품가격`은 기본 키의 **일부인 '상품번호'에만** 종속됩니다. (**부분 종속**)

### 3. ❌ 이상 현상

부분 종속성으로 인해 다음과 같은 문제가 발생합니다.

* **갱신 이상:** '노트북'의 가격을 수정하려면, 주문번호 100과 101에 있는 **모든 '노트북' 행**의 `상품가격`을 중복해서 수정해야 합니다. (데이터 중복)
* **삽입 이상:** 새로운 상품(P003)을 등록하고 싶어도, 아직 주문이 없으면(`주문번호`가 없으면) 상품 정보를 테이블에 삽입할 수 없습니다.

### 4. ✅ 2NF로 정규화

부분 함수 종속성을 제거하고 2NF를 만족시키려면, **부분 키에 종속되는 속성**을 **별도의 테이블**로 분리해야 합니다.

#### A. 주문 상세 (Orders\_Detail) 테이블

주문 정보와 수량 등 **전체 키**에 종속되는 속성만 남깁니다.

| 주문번호 (PK, FK) | 상품번호 (PK, FK) | 수량 |
| :---: | :---: | :---: |
| 100 | P001 | 2 |
| 100 | P002 | 1 |
| 101 | P001 | 3 |

#### B. 상품 (Products) 테이블

**부분 키**에 종속되었던 속성들을 분리합니다.

| 상품번호 (PK) | 상품명 | 상품가격 |
| :---: | :---: | :---: |
| P001 | 노트북 | 1,500,000 |
| P002 | 마우스 | 30,000 |



* **결과:** 이제 '상품명'과 '상품가격' 정보는 **'상품 테이블'에 단 한 번만** 저장되므로 중복이 제거됩니다. '주문 상세 테이블'에서는 상품을 찾기 위한 외래 키(`상품번호`)만 남습니다.



## 🥉 제3 정규형 (Third Normal Form, 3NF): 이행적 함수 종속성 제거
3NF는 2NF를 만족한 테이블에서 비-키 속성 간의 종속성, 즉 이행적 함수 종속성을 제거하여 데이터의 독립성을 확보하는 단계입니다.

제3 정규형(3NF)은 다음 조건을 만족해야 합니다.

1.  **2NF (제2 정규형)를 만족**해야 합니다.
2.  **이행적 함수 종속성 (Transitive Dependency)**을 제거해야 합니다.

**이행적 함수 종속성**이란, 기본 키가 아닌 속성이 다른 비-키 속성을 결정하고, 이 비-키 속성이 다시 기본 키에 의해 결정되는 **간접적인 종속 관계**를 말합니다.

* 수식으로 표현하면, $A$가 기본 키일 때, $A \rightarrow B$ 이고 $B \rightarrow C$ 이면, $A \rightarrow C$ (이행 종속) 관계가 성립합니다.

### 📝 실질적인 예시: '직원 정보' 테이블

직원들의 정보와 소속 부서 정보를 담고 있는 테이블을 예로 들어 보겠습니다. 2NF는 이미 만족한다고 가정합니다.

**정규화 이전 (2NF는 만족하지만 3NF는 만족하지 않음)**

| 직원번호 (PK) | 직원명 | 부서번호 | 부서명 | 부서전화번호 |
| :---: | :---: | :---: | :---: | :---: |
| E001 | 김철수 | D10 | 마케팅 | 1234 |
| E002 | 박영희 | D20 | 개발 | 5678 |
| E003 | 이민호 | D10 | 마케팅 | 1234 |

* **기본 키 (PK):** **직원번호** (단일 키이므로 2NF는 자동 만족)
* **비-키 속성:** 직원명, 부서번호, 부서명, 부서전화번호

#### 🚨 3NF 위반 (이행적 함수 종속성)

이 테이블에는 다음과 같은 종속성이 존재합니다.

1.  **직원번호 $\rightarrow$ 직원명, 부서번호**: `직원번호`는 모든 속성을 유일하게 결정합니다.
2.  **부서번호 $\rightarrow$ 부서명, 부서전화번호**: `부서번호`를 알면 `부서명`과 `부서전화번호`를 알 수 있습니다.

**문제:** **직원번호 $\rightarrow$ 부서번호** 이고 **부서번호 $\rightarrow$ 부서명, 부서전화번호** 이므로, **직원번호 $\rightarrow$ 부서명, 부서전화번호**라는 **이행적 종속성**이 발생합니다. 이는 **부서번호**가 비-키 속성임에도 불구하고 다른 비-키 속성인 **부서명**과 **부서전화번호**를 결정하는 **결정자(Determinant)** 역할을 하기 때문입니다.

#### ❌ 이로 인해 발생하는 이상 현상

1.  **갱신 이상 (Update Anomaly):** '마케팅' 부서의 전화번호가 '1234'에서 '9999'로 변경되면, '마케팅' 부서에 소속된 모든 직원(E001, E003)의 행을 찾아 개별적으로 수정해야 합니다. 데이터 중복으로 인해 오류 발생 가능성이 높습니다.
2.  **삽입 이상 (Insertion Anomaly):** 새로운 부서(예: D30, 디자인, 7777)가 신설되었지만, 아직 그 부서에 소속된 직원이 없다면(`직원번호`가 없으면) 이 정보를 테이블에 삽입할 수 없습니다.

---

## ✅ 3NF를 만족하도록 테이블 분해

이행적 함수 종속성을 제거하고 3NF를 만족시키려면, **비-키 결정자($B$)와 그에 종속되는 속성($C$)**를 **별도의 테이블**로 분리해야 합니다.

### 1. 직원 (Employee) 테이블

직원 정보와 **부서번호(FK)**만 남깁니다.

| 직원번호 (PK) | 직원명 | 부서번호 (FK) |
| :---: | :---: | :---: |
| E001 | 김철수 | D10 |
| E002 | 박영희 | D20 |
| E003 | 이민호 | D10 |

* **기본 키:** 직원번호
* **종속성:** 직원번호 $\rightarrow$ 직원명, 부서번호
* **상태:** 3NF 만족

### 2. 부서 (Department) 테이블

비-키 결정자였던 **부서번호**를 기본 키로 만들고, 그에 종속되던 속성들을 분리합니다.

| 부서번호 (PK) | 부서명 | 부서전화번호 |
| :---: | :---: | :---: |
| D10 | 마케팅 | 1234 |
| D20 | 개발 | 5678 |

* **기본 키:** 부서번호
* **종속성:** 부서번호 $\rightarrow$ 부서명, 부서전화번호
* **상태:** 3NF 만족



#### ✨ 3NF 달성 후 이점

* **갱신 용이:** 마케팅 부서의 전화번호가 바뀌면 이제 **부서 테이블**에서 D10 행 하나만 수정하면 됩니다.
* **삽입 용이:** 새로운 부서(D30, 디자인)는 **부서 테이블**에 직원이 없어도 쉽게 추가할 수 있습니다.

**요약:** **3NF는 비-키 속성($B$)이 다른 비-키 속성($C$)을 결정하는 간접 종속 관계(이행 종속)를 테이블에서 분리하여 데이터 중복을 제거하고 독립성을 확보하는 단계**입니다.



## 🧐 3NF 위반의 핵심 문제: 이행적 함수 종속성

3NF 위반이 발생하는 **핵심 문제**는 바로 **'이행적 함수 종속성'** 때문에 생기는 데이터의 **불필요한 중복**과 그로 인한 **관리의 어려움**입니다.

이해가 쉽도록, 위반 상황을 다시 한번 분석해 보겠습니다.

---

### 1. 기본 함수 종속 관계 (정상)

| 직원번호 (A) | 직원명 | 부서번호 (B) | 부서명 (C) | 부서전화번호 (D) |
| :---: | :---: | :---: | :---: | :---: |
| E001 | 김철수 | **D10** | 마케팅 | 1234 |
| E003 | 이민호 | **D10** | 마케팅 | 1234 |

* **직원번호 (A)**는 테이블의 **기본 키**입니다.

1.  **A → B:** `직원번호`는 그 직원의 `부서번호`를 결정합니다. (정상적인 기본 키 종속)

### 2. 비-키 속성 간의 종속 관계 (문제)

2.  **B → C, D:** `부서번호`는 `부서명`과 `부서전화번호`를 결정합니다.

여기서 문제가 발생합니다. `부서번호`는 **기본 키(직원번호)가 아닌 단순한 비-키 속성**입니다.

### 3. 이행적 종속성 (Transitive Dependency)

이 두 관계를 합치면 다음과 같은 **간접적인 종속**이 형성됩니다.

$$
\text{직원번호 (A)} \rightarrow \text{부서번호 (B)} \rightarrow \text{부서명, 부서전화번호 (C, D)}
$$

* **'부서명'과 '부서전화번호'**는 **기본 키인 '직원번호'에 의해 직접적으로 결정되지 않고**, 중간에 있는 **'부서번호'**를 *거쳐서* 결정됩니다. 이것이 바로 **이행적 함수 종속**입니다.

---

## 🛑 왜 이것이 '문제'인가요?

이 이행적 종속성($A \rightarrow B \rightarrow C$)이 허용되면, 부서와 관련된 정보(부서명, 전화번호)가 **직원 수만큼 중복**되어 테이블에 저장됩니다.

#### 1. 데이터 중복과 불필요한 저장 공간 낭비

위 예시에서 `마케팅` 부서에 직원이 100명이 있다면, **'마케팅, 1234'**라는 정보가 100번 반복되어 저장됩니다. 부서 정보는 부서 자체에 대한 정보이지, 특정 직원에 대한 정보가 아닙니다.

#### 2. 갱신 이상 (Update Anomaly)

만약 `마케팅` 부서의 전화번호가 '1234'에서 '9999'로 변경되었다고 가정해 봅시다.

* 이 테이블에서는 '마케팅' 부서에 소속된 직원 100명의 **모든 행**을 찾아서 `부서전화번호`를 **100번 수정**해야 합니다.
* 만약 실수로 99개만 수정하고 1개를 놓친다면, 데이터베이스에는 `마케팅` 부서의 전화번호가 '9999'와 '1234'로 **혼재하는 심각한 데이터 불일치**가 발생합니다.

#### 3. 삽입 이상 (Insertion Anomaly)

새로운 부서인 '디자인(D30)' 부서를 만들고, 전화번호는 '7777'로 정했다고 가정해 봅시다.

* 이 테이블은 **직원번호**를 기본 키로 사용하기 때문에, **직원 정보 없이는 부서 정보만 단독으로 삽입할 수 없습니다.** (직원번호에 NULL을 허용하지 않는다면)
* 부서가 존재함에도 불구하고 직원이 배정될 때까지 부서 정보를 기록할 수 없는 모순이 발생합니다.

---

## ✅ 해결책: 테이블 분리 (3NF 달성)

3NF는 이 문제를 해결하기 위해 **이행적 종속성을 야기한 비-키 결정자(부서번호)**를 중심으로 테이블을 분리합니다.

1.  **직원 테이블:** 순수하게 **직원 자체**에 대한 정보와 **부서번호(FK)**만 남깁니다. ($A \rightarrow B$ 관계 유지)
2.  **부서 테이블:** **부서번호**를 기본 키로 만들어 **부서 자체**에 대한 정보($B \rightarrow C, D$ 관계)만 저장합니다.

